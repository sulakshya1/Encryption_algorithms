import random
import math
from math import isqrt

#***** generating 2 random prime number*****
#seive of era-tos-thenes.
def generate_prime(number:int) ->list[int]:
    if number <=2:
        return []
    is_prime = [True]*number
    is_prime[0] = is_prime[1]=False

    for i in range(2, isqrt(number)):
        if is_prime[i]:
            for x in range(i*i, number, i):
                is_prime[x]= False

    return [i for i in range(number) if  is_prime[i]]
    pass
primes=generate_prime(10000)
p,q = random.sample(primes, 2)
print(p,q)
#*****end of 2 random generation of 2 random prime number*****

#euclidian function implementation for future me
def inverse_mod(e, phi):
    for d in range(3 ,phi):
        if (d*e)%phi == 1:
            return d
    pass
#*** The real Thing***
n = p * q
phi_n = (p-1)*(q-1)

encryption_key=random.randint(3, phi_n-1)#randint stops at (n, n+1)

while math.gcd(encryption_key, phi_n)!= 1:
    encryption_key = random.randint(3, phi_n - 1)

decryption_key = inverse_mod(encryption_key,phi_n)

print("\nencryption key:",encryption_key)
print("\ndecryption key:", decryption_key)
print("\nn:",n)

message = input("\nenter your message: ")


#****message encryption****
message_encoded = [ord(ch)for ch in message]
#cipher is generated by (m^e) mod N hence pow(a,b,c)
cipher_text = [pow(ch,encryption_key,n)for ch in message_encoded]
print("\ncipher text:",cipher_text)
#****message decryption****
    #to decrypt me use (m^d)mod N
message_encoded = [pow(ch,decryption_key,n) for ch in cipher_text]

decrypted_text = "".join(chr(ch) for ch in message_encoded)

print("decrypted_text:",decrypted_text)